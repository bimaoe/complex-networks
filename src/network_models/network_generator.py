"""This module creates networks based on complex networks models with the aid of the iGraph library."""

import igraph
import numpy
import matplotlib.pyplot as pyplot

class NetworkGenerator(object):
	"""Network generator."""

	@classmethod
	def generate(cls, size_of_network, type_of_network, parameter_list):
		"""Generates a network of the given type and with the given parameters.
		Parameters:
			size_of_network: An integer indicating the number of nodes in the network.
			type_of_network: An integer that represents the desired model for the network.
			parameter_list: A list of parameters for the given type.

		Returns:
			An igraph graph that is the generated network.
		"""

	@classmethod
	def generate_BA(cls, size_of_network, parameter_list):
		"""Generates a graph based on the Barabasi-Albert model.

		Parameters:
			size_of_network: An integer indicating the number of nodes in the network.
			parameter_list: A list [number_of_outgoing_edges, is_directed, power_of_nonlinear_model].
				number_of_outgoing_edges: A positive integer indicating the number of outgoing edges for each vertex.
				is_directed: A boolean indicating whether the graph is directed.
				power_of_non_linear_model: A double indicating the power of the model(optional).

		Returns:
			An igraph graph based on the Barabasi-Albert model.
		"""
		return igraph.GraphBase.Barabasi(n = size_of_network, m = parameter_list[0], directed = parameter_list[1], power = parameter_list[2] if len(parameter_list) > 2 else 1)
	
	@classmethod
	def generate_ER(cls, size_of_network, parameter_list):
		"""Generates a graph based on the Erdos-Renyi model.

		Parameters:
			size_of_network: An integer indicating the number of nodes in the network.
			parameter_list: A list [probability_of_connection, is_directed].
				probability_of_connection: A double indicating the probability of connecting any pair of nodes.
				is_directed: A boolean indicating whether the graph is directed.

		Returns:
			An igraph graph based on the Erdos-Renyi model.
		"""
		return igraph.GraphBase.Erdos_Renyi(n = size_of_network, p = parameter_list[0], directed = parameter_list[1])

	@classmethod
	def generate_WS(cls, size_of_network, parameter_list):
		"""Generates a graph based on the Watts-Strogatz model.

		Parameters:
			size_of_network: An integer indicating the number of nodes in the network.
			parameter_list: A list [distance_of_connection, rewiring_probability].
				distance_of_connection: A positive integer indicating the distance within which two vertices will be connected.
				rewiring_probability: A double indicating the rewiring probability.

		Returns:
			An igraph graph based on the Barabasi-Albert model.
		"""
		return igraph.GraphBase.Watts_Strogatz(dim = 1, size = size_of_network, nei = parameter_list[0], p = parameter_list[1], loops = False, multiple = False)

	@classmethod
	def generate_SF2ER(cls, size_of_network, parameter_list):
		"""Generates a graph based on a configuration model.
		
		Parameters:
			size_of_network: An integer indicating the number of nodes in the network.
			parameter_list: A list [alpha].
				alpha: A double between 0 and 1 indicating the probability of choosing a node without taking the degree into account.
				m0: An integer indicating the number of nodes in the starting fully connected network.
				m: An integer indicating the number of outgoing edges for each node except the m0 starting ones.

		Returns:
			An igraph graph based on a configuration model.
		"""
		alpha = parameter_list[0]
		m0 = parameter_list[1]
		m = parameter_list[2]
		pa_deg = [0] * size_of_network # Number of edges generated by preferential attachment for each node.

		# Create an undirected graph with size_of_network nodes.
		g = igraph.Graph(size_of_network)

		# Create the fully connected graph.
		for i in xrange(0, m0):
			g.add_edges([(i, j) for j in range(0, m0) if j > i])
			pa_deg[i] = m0-1

		# Add the remaining nodes.
		for i in xrange(m0, size_of_network):
			all_nodes = [node for node in xrange(0, size_of_network) if node != i]
			if numpy.random.random() < alpha:
				# Connect to m nodes with uniform probability distribution.
				g.add_edges([(i, j) for j in numpy.random.choice(all_nodes, m, False)])
			else:
				# Connect to m nodes with probability proportional to the degree.
				deg = [pa_deg[node] for node in all_nodes]
				total = sum(deg)
				prob = [degree*1.0/total for degree in deg]
				chosen_nodes = numpy.random.choice(all_nodes, m, False, prob)
				for node in chosen_nodes:
					pa_deg[node] += 1
					pa_deg[i] += 1
					g.add_edge(i, node)
		return g

if __name__ == '__main__':
	# print NetworkGenerator.generate_BA(100, [3, False])
	# print NetworkGenerator.generate_ER(100, [0.5, False])
	# print NetworkGenerator.generate_WS(100, [2, 0.5])
	pyplot.hist(NetworkGenerator.generate_SF2ER(1000, [0, 5, 5]).degree(), 100)
	pyplot.show()
